1. Registration (Sign-Up)
	1.	User fills out the registration form (email, password, name, role) in the React UI.
	2.	React sends a POST to /auth/register on the NestJS API with { email, password, name, role }.
	3.	NestJS AuthController receives the request:
	•	Validates the payload (email format, password strength, role is one of admin|teacher|student).
	•	Hashes the password with bcrypt (or Argon2).
	•	Creates a new user record in PostgreSQL (users table) via TypeORM.
	4.	Optionally, NestJS sends a confirmation email with a one-time token link (/auth/confirm?token=…).
	5.	User clicks the email link → React UI calls /auth/confirm → NestJS verifies the token, marks emailConfirmed = true.

⸻

2. Login (Sign-In)
	1.	User enters email & password in React’s login form.
	2.	React calls POST /auth/login with { email, password }.
	3.	NestJS AuthController’s login() action:
	•	Uses a Passport local strategy to validate credentials (compare hashed password).
	•	If valid, issues:
	•	Access Token (JWT, short-lived, e.g. 15 min)
	•	Refresh Token (JWT, longer-lived, e.g. 7 days)
	•	Stores the refresh token in Redis (keyed by userId) for revocation and rotation.
	4.	NestJS returns tokens in secure, HTTP-only cookies:
	•	Set-Cookie: access_token=…; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=900;
	•	Set-Cookie: refresh_token=…; HttpOnly; Secure; SameSite=Strict; Path=/auth/refresh; Max-Age=604800;
	5.	React then considers the user “logged in” and redirects to the appropriate dashboard.

⸻

3. Accessing Protected API Routes
	•	All protected endpoints (e.g., /projects, /assessments, /submissions) are guarded by Nest’s JwtAuthGuard.
	•	The guard:
	1.	Reads the access_token cookie.
	2.	Verifies the JWT signature and expiry.
	3.	Attaches the decoded user object to request.user.
	•	Controllers can then use a RolesGuard (custom decorator @Roles('teacher'), etc.) to enforce role-based access, throwing 403 Forbidden if the user lacks the required role.

⸻

4. Token Refresh Flow
	1.	When the access token expires, the React app detects a 401 Unauthorized.
	2.	React calls POST /auth/refresh (automatically including the refresh_token cookie).
	3.	NestJS:
	•	Validates the refresh JWT and checks it against the stored token in Redis.
	•	If valid and not revoked, issues a new pair of access + refresh tokens (rotating the refresh token).
	•	Updates the Redis entry with the new refresh token.
	4.	New tokens are set in cookies again; React retries the original request.

⸻

5. Logout
	1.	User clicks “Logout” in React.
	2.	React calls POST /auth/logout.
	3.	NestJS:
	•	Deletes the refresh token record from Redis.
	•	Clears both cookies (Set-Cookie: access_token=; Max-Age=0; …, etc.).
	4.	React redirects to the public login page.

⸻

6. Password Reset
	1.	User clicks “Forgot Password” → enters email → React calls POST /auth/forgot-password.
	2.	NestJS generates a one-time reset token, stores it (in Redis or DB) with a short TTL (e.g., 1 hour), emails the user a link /auth/reset?token=….
	3.	User clicks link → React displays a reset form → submits new password to POST /auth/reset.
	4.	NestJS verifies token, hashes the new password, updates the user record, invalidates the reset token (and existing refresh tokens).